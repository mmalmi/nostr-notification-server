// automatically generated by the FlatBuffers compiler, do not modify


// @generated

extern crate flatbuffers;

#[allow(unused_imports, dead_code)]
pub mod subscription {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum WebPushSubscriptionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WebPushSubscription<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WebPushSubscription<'a> {
  type Inner = WebPushSubscription<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WebPushSubscription<'a> {
  pub const VT_ENDPOINT: flatbuffers::VOffsetT = 4;
  pub const VT_AUTH: flatbuffers::VOffsetT = 6;
  pub const VT_P256DH: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WebPushSubscription { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args WebPushSubscriptionArgs<'args>
  ) -> flatbuffers::WIPOffset<WebPushSubscription<'bldr>> {
    let mut builder = WebPushSubscriptionBuilder::new(_fbb);
    if let Some(x) = args.p256dh { builder.add_p256dh(x); }
    if let Some(x) = args.auth { builder.add_auth(x); }
    if let Some(x) = args.endpoint { builder.add_endpoint(x); }
    builder.finish()
  }


  #[inline]
  pub fn endpoint(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WebPushSubscription::VT_ENDPOINT, None)}
  }
  #[inline]
  pub fn auth(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WebPushSubscription::VT_AUTH, None)}
  }
  #[inline]
  pub fn p256dh(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WebPushSubscription::VT_P256DH, None)}
  }
}

impl flatbuffers::Verifiable for WebPushSubscription<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("endpoint", Self::VT_ENDPOINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("auth", Self::VT_AUTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("p256dh", Self::VT_P256DH, false)?
     .finish();
    Ok(())
  }
}
pub struct WebPushSubscriptionArgs<'a> {
    pub endpoint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub auth: Option<flatbuffers::WIPOffset<&'a str>>,
    pub p256dh: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for WebPushSubscriptionArgs<'a> {
  #[inline]
  fn default() -> Self {
    WebPushSubscriptionArgs {
      endpoint: None,
      auth: None,
      p256dh: None,
    }
  }
}

pub struct WebPushSubscriptionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WebPushSubscriptionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_endpoint(&mut self, endpoint: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WebPushSubscription::VT_ENDPOINT, endpoint);
  }
  #[inline]
  pub fn add_auth(&mut self, auth: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WebPushSubscription::VT_AUTH, auth);
  }
  #[inline]
  pub fn add_p256dh(&mut self, p256dh: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WebPushSubscription::VT_P256DH, p256dh);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WebPushSubscriptionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WebPushSubscriptionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WebPushSubscription<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WebPushSubscription<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WebPushSubscription");
      ds.field("endpoint", &self.endpoint());
      ds.field("auth", &self.auth());
      ds.field("p256dh", &self.p256dh());
      ds.finish()
  }
}
pub enum TagOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Tag<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Tag<'a> {
  type Inner = Tag<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Tag<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Tag { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TagArgs<'args>
  ) -> flatbuffers::WIPOffset<Tag<'bldr>> {
    let mut builder = TagBuilder::new(_fbb);
    if let Some(x) = args.values { builder.add_values(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Tag::VT_KEY, None)}
  }
  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Tag::VT_VALUES, None)}
  }
}

impl flatbuffers::Verifiable for Tag<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("values", Self::VT_VALUES, false)?
     .finish();
    Ok(())
  }
}
pub struct TagArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for TagArgs<'a> {
  #[inline]
  fn default() -> Self {
    TagArgs {
      key: None,
      values: None,
    }
  }
}

pub struct TagBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TagBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tag::VT_KEY, key);
  }
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tag::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TagBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TagBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Tag<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Tag<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Tag");
      ds.field("key", &self.key());
      ds.field("values", &self.values());
      ds.finish()
  }
}
pub enum SubscriptionFilterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SubscriptionFilter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SubscriptionFilter<'a> {
  type Inner = SubscriptionFilter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SubscriptionFilter<'a> {
  pub const VT_IDS: flatbuffers::VOffsetT = 4;
  pub const VT_AUTHORS: flatbuffers::VOffsetT = 6;
  pub const VT_KINDS: flatbuffers::VOffsetT = 8;
  pub const VT_SEARCH: flatbuffers::VOffsetT = 10;
  pub const VT_TAGS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SubscriptionFilter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SubscriptionFilterArgs<'args>
  ) -> flatbuffers::WIPOffset<SubscriptionFilter<'bldr>> {
    let mut builder = SubscriptionFilterBuilder::new(_fbb);
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.search { builder.add_search(x); }
    if let Some(x) = args.kinds { builder.add_kinds(x); }
    if let Some(x) = args.authors { builder.add_authors(x); }
    if let Some(x) = args.ids { builder.add_ids(x); }
    builder.finish()
  }


  #[inline]
  pub fn ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SubscriptionFilter::VT_IDS, None)}
  }
  #[inline]
  pub fn authors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SubscriptionFilter::VT_AUTHORS, None)}
  }
  #[inline]
  pub fn kinds(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(SubscriptionFilter::VT_KINDS, None)}
  }
  #[inline]
  pub fn search(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SubscriptionFilter::VT_SEARCH, None)}
  }
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag>>>>(SubscriptionFilter::VT_TAGS, None)}
  }
}

impl flatbuffers::Verifiable for SubscriptionFilter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ids", Self::VT_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("authors", Self::VT_AUTHORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("kinds", Self::VT_KINDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("search", Self::VT_SEARCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Tag>>>>("tags", Self::VT_TAGS, false)?
     .finish();
    Ok(())
  }
}
pub struct SubscriptionFilterArgs<'a> {
    pub ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub authors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub kinds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub search: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag<'a>>>>>,
}
impl<'a> Default for SubscriptionFilterArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubscriptionFilterArgs {
      ids: None,
      authors: None,
      kinds: None,
      search: None,
      tags: None,
    }
  }
}

pub struct SubscriptionFilterBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SubscriptionFilterBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ids(&mut self, ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubscriptionFilter::VT_IDS, ids);
  }
  #[inline]
  pub fn add_authors(&mut self, authors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubscriptionFilter::VT_AUTHORS, authors);
  }
  #[inline]
  pub fn add_kinds(&mut self, kinds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubscriptionFilter::VT_KINDS, kinds);
  }
  #[inline]
  pub fn add_search(&mut self, search: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubscriptionFilter::VT_SEARCH, search);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Tag<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubscriptionFilter::VT_TAGS, tags);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SubscriptionFilterBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SubscriptionFilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SubscriptionFilter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SubscriptionFilter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SubscriptionFilter");
      ds.field("ids", &self.ids());
      ds.field("authors", &self.authors());
      ds.field("kinds", &self.kinds());
      ds.field("search", &self.search());
      ds.field("tags", &self.tags());
      ds.finish()
  }
}
pub enum SubscriptionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Subscription<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Subscription<'a> {
  type Inner = Subscription<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Subscription<'a> {
  pub const VT_WEBHOOKS: flatbuffers::VOffsetT = 4;
  pub const VT_WEB_PUSH_SUBSCRIPTIONS: flatbuffers::VOffsetT = 6;
  pub const VT_FILTER: flatbuffers::VOffsetT = 8;
  pub const VT_SUBSCRIBER: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Subscription { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SubscriptionArgs<'args>
  ) -> flatbuffers::WIPOffset<Subscription<'bldr>> {
    let mut builder = SubscriptionBuilder::new(_fbb);
    if let Some(x) = args.subscriber { builder.add_subscriber(x); }
    if let Some(x) = args.filter { builder.add_filter(x); }
    if let Some(x) = args.web_push_subscriptions { builder.add_web_push_subscriptions(x); }
    if let Some(x) = args.webhooks { builder.add_webhooks(x); }
    builder.finish()
  }


  #[inline]
  pub fn webhooks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Subscription::VT_WEBHOOKS, None)}
  }
  #[inline]
  pub fn web_push_subscriptions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WebPushSubscription<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WebPushSubscription>>>>(Subscription::VT_WEB_PUSH_SUBSCRIPTIONS, None)}
  }
  #[inline]
  pub fn filter(&self) -> Option<SubscriptionFilter<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SubscriptionFilter>>(Subscription::VT_FILTER, None)}
  }
  #[inline]
  pub fn subscriber(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Subscription::VT_SUBSCRIBER, None)}
  }
}

impl flatbuffers::Verifiable for Subscription<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("webhooks", Self::VT_WEBHOOKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WebPushSubscription>>>>("web_push_subscriptions", Self::VT_WEB_PUSH_SUBSCRIPTIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SubscriptionFilter>>("filter", Self::VT_FILTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subscriber", Self::VT_SUBSCRIBER, false)?
     .finish();
    Ok(())
  }
}
pub struct SubscriptionArgs<'a> {
    pub webhooks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub web_push_subscriptions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WebPushSubscription<'a>>>>>,
    pub filter: Option<flatbuffers::WIPOffset<SubscriptionFilter<'a>>>,
    pub subscriber: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SubscriptionArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubscriptionArgs {
      webhooks: None,
      web_push_subscriptions: None,
      filter: None,
      subscriber: None,
    }
  }
}

pub struct SubscriptionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SubscriptionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_webhooks(&mut self, webhooks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Subscription::VT_WEBHOOKS, webhooks);
  }
  #[inline]
  pub fn add_web_push_subscriptions(&mut self, web_push_subscriptions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WebPushSubscription<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Subscription::VT_WEB_PUSH_SUBSCRIPTIONS, web_push_subscriptions);
  }
  #[inline]
  pub fn add_filter(&mut self, filter: flatbuffers::WIPOffset<SubscriptionFilter<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SubscriptionFilter>>(Subscription::VT_FILTER, filter);
  }
  #[inline]
  pub fn add_subscriber(&mut self, subscriber: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Subscription::VT_SUBSCRIBER, subscriber);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SubscriptionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SubscriptionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Subscription<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Subscription<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Subscription");
      ds.field("webhooks", &self.webhooks());
      ds.field("web_push_subscriptions", &self.web_push_subscriptions());
      ds.field("filter", &self.filter());
      ds.field("subscriber", &self.subscriber());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Subscription`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_subscription_unchecked`.
pub fn root_as_subscription(buf: &[u8]) -> Result<Subscription, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Subscription>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Subscription` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_subscription_unchecked`.
pub fn size_prefixed_root_as_subscription(buf: &[u8]) -> Result<Subscription, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Subscription>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Subscription` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_subscription_unchecked`.
pub fn root_as_subscription_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Subscription<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Subscription<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Subscription` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_subscription_unchecked`.
pub fn size_prefixed_root_as_subscription_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Subscription<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Subscription<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Subscription and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Subscription`.
pub unsafe fn root_as_subscription_unchecked(buf: &[u8]) -> Subscription {
  flatbuffers::root_unchecked::<Subscription>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Subscription and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Subscription`.
pub unsafe fn size_prefixed_root_as_subscription_unchecked(buf: &[u8]) -> Subscription {
  flatbuffers::size_prefixed_root_unchecked::<Subscription>(buf)
}
#[inline]
pub fn finish_subscription_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Subscription<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_subscription_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Subscription<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod subscription

